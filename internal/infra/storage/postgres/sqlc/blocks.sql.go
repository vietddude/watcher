// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: blocks.sql

package sqlc

import (
	"context"

	"github.com/lib/pq"
)

const createBlock = `-- name: CreateBlock :exec
INSERT INTO blocks (
    chain_id,
    block_number,
    block_hash,
    parent_hash,
    block_timestamp,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6
) ON CONFLICT (chain_id, block_number) DO UPDATE
SET
    block_hash = EXCLUDED.block_hash,
    parent_hash = EXCLUDED.parent_hash,
    block_timestamp = EXCLUDED.block_timestamp,
    status = EXCLUDED.status
`

type CreateBlockParams struct {
	ChainID        string `db:"chain_id" json:"chain_id"`
	BlockNumber    int64  `db:"block_number" json:"block_number"`
	BlockHash      string `db:"block_hash" json:"block_hash"`
	ParentHash     string `db:"parent_hash" json:"parent_hash"`
	BlockTimestamp int64  `db:"block_timestamp" json:"block_timestamp"`
	Status         string `db:"status" json:"status"`
}

func (q *Queries) CreateBlock(ctx context.Context, arg CreateBlockParams) error {
	_, err := q.db.ExecContext(ctx, createBlock,
		arg.ChainID,
		arg.BlockNumber,
		arg.BlockHash,
		arg.ParentHash,
		arg.BlockTimestamp,
		arg.Status,
	)
	return err
}

const createBlocksBatch = `-- name: CreateBlocksBatch :exec
INSERT INTO blocks (chain_id, block_number, block_hash, parent_hash, block_timestamp, status)
SELECT
    unnest($1::varchar[]) AS chain_id,
    unnest($2::bigint[]) AS block_number,
    unnest($3::varchar[]) AS block_hash,
    unnest($4::varchar[]) AS parent_hash,
    unnest($5::bigint[]) AS block_timestamp,
    unnest($6::varchar[]) AS status
ON CONFLICT (chain_id, block_number) DO UPDATE
SET block_hash = EXCLUDED.block_hash,
    parent_hash = EXCLUDED.parent_hash,
    block_timestamp = EXCLUDED.block_timestamp,
    status = EXCLUDED.status
`

type CreateBlocksBatchParams struct {
	Column1 []string `db:"column_1" json:"column_1"`
	Column2 []int64  `db:"column_2" json:"column_2"`
	Column3 []string `db:"column_3" json:"column_3"`
	Column4 []string `db:"column_4" json:"column_4"`
	Column5 []int64  `db:"column_5" json:"column_5"`
	Column6 []string `db:"column_6" json:"column_6"`
}

func (q *Queries) CreateBlocksBatch(ctx context.Context, arg CreateBlocksBatchParams) error {
	_, err := q.db.ExecContext(ctx, createBlocksBatch,
		pq.Array(arg.Column1),
		pq.Array(arg.Column2),
		pq.Array(arg.Column3),
		pq.Array(arg.Column4),
		pq.Array(arg.Column5),
		pq.Array(arg.Column6),
	)
	return err
}

const deleteBlocksInRange = `-- name: DeleteBlocksInRange :exec
DELETE FROM blocks
WHERE chain_id = $1 AND block_number BETWEEN $2 AND $3
`

type DeleteBlocksInRangeParams struct {
	ChainID       string `db:"chain_id" json:"chain_id"`
	BlockNumber   int64  `db:"block_number" json:"block_number"`
	BlockNumber_2 int64  `db:"block_number_2" json:"block_number_2"`
}

func (q *Queries) DeleteBlocksInRange(ctx context.Context, arg DeleteBlocksInRangeParams) error {
	_, err := q.db.ExecContext(ctx, deleteBlocksInRange, arg.ChainID, arg.BlockNumber, arg.BlockNumber_2)
	return err
}

const deleteBlocksOlderThan = `-- name: DeleteBlocksOlderThan :exec
DELETE FROM blocks
WHERE chain_id = $1 AND block_timestamp < $2
`

type DeleteBlocksOlderThanParams struct {
	ChainID        string `db:"chain_id" json:"chain_id"`
	BlockTimestamp int64  `db:"block_timestamp" json:"block_timestamp"`
}

func (q *Queries) DeleteBlocksOlderThan(ctx context.Context, arg DeleteBlocksOlderThanParams) error {
	_, err := q.db.ExecContext(ctx, deleteBlocksOlderThan, arg.ChainID, arg.BlockTimestamp)
	return err
}

const findGaps = `-- name: FindGaps :many
SELECT
    t1.block_number + 1 AS from_block,
    MIN(t2.block_number) - 1 AS to_block
FROM blocks AS t1
JOIN blocks AS t2 ON t1.chain_id = t2.chain_id AND t1.block_number < t2.block_number
WHERE t1.chain_id = $1
  AND t1.block_number >= $2
  AND t2.block_number <= $3
GROUP BY t1.block_number
HAVING t1.block_number < MIN(t2.block_number) - 1
`

type FindGapsParams struct {
	ChainID       string `db:"chain_id" json:"chain_id"`
	BlockNumber   int64  `db:"block_number" json:"block_number"`
	BlockNumber_2 int64  `db:"block_number_2" json:"block_number_2"`
}

type FindGapsRow struct {
	FromBlock int32 `db:"from_block" json:"from_block"`
	ToBlock   int32 `db:"to_block" json:"to_block"`
}

func (q *Queries) FindGaps(ctx context.Context, arg FindGapsParams) ([]FindGapsRow, error) {
	rows, err := q.db.QueryContext(ctx, findGaps, arg.ChainID, arg.BlockNumber, arg.BlockNumber_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindGapsRow
	for rows.Next() {
		var i FindGapsRow
		if err := rows.Scan(&i.FromBlock, &i.ToBlock); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockByHash = `-- name: GetBlockByHash :one
SELECT chain_id, block_number, block_hash, parent_hash, block_timestamp, status, created_at FROM blocks
WHERE chain_id = $1 AND block_hash = $2
LIMIT 1
`

type GetBlockByHashParams struct {
	ChainID   string `db:"chain_id" json:"chain_id"`
	BlockHash string `db:"block_hash" json:"block_hash"`
}

func (q *Queries) GetBlockByHash(ctx context.Context, arg GetBlockByHashParams) (Block, error) {
	row := q.db.QueryRowContext(ctx, getBlockByHash, arg.ChainID, arg.BlockHash)
	var i Block
	err := row.Scan(
		&i.ChainID,
		&i.BlockNumber,
		&i.BlockHash,
		&i.ParentHash,
		&i.BlockTimestamp,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getBlockByNumber = `-- name: GetBlockByNumber :one
SELECT chain_id, block_number, block_hash, parent_hash, block_timestamp, status, created_at FROM blocks
WHERE chain_id = $1 AND block_number = $2
LIMIT 1
`

type GetBlockByNumberParams struct {
	ChainID     string `db:"chain_id" json:"chain_id"`
	BlockNumber int64  `db:"block_number" json:"block_number"`
}

func (q *Queries) GetBlockByNumber(ctx context.Context, arg GetBlockByNumberParams) (Block, error) {
	row := q.db.QueryRowContext(ctx, getBlockByNumber, arg.ChainID, arg.BlockNumber)
	var i Block
	err := row.Scan(
		&i.ChainID,
		&i.BlockNumber,
		&i.BlockHash,
		&i.ParentHash,
		&i.BlockTimestamp,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestBlock = `-- name: GetLatestBlock :one
SELECT chain_id, block_number, block_hash, parent_hash, block_timestamp, status, created_at FROM blocks
WHERE chain_id = $1
ORDER BY block_number DESC
LIMIT 1
`

func (q *Queries) GetLatestBlock(ctx context.Context, chainID string) (Block, error) {
	row := q.db.QueryRowContext(ctx, getLatestBlock, chainID)
	var i Block
	err := row.Scan(
		&i.ChainID,
		&i.BlockNumber,
		&i.BlockHash,
		&i.ParentHash,
		&i.BlockTimestamp,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const updateBlockStatus = `-- name: UpdateBlockStatus :exec
UPDATE blocks
SET status = $1
WHERE chain_id = $2 AND block_number = $3
`

type UpdateBlockStatusParams struct {
	Status      string `db:"status" json:"status"`
	ChainID     string `db:"chain_id" json:"chain_id"`
	BlockNumber int64  `db:"block_number" json:"block_number"`
}

func (q *Queries) UpdateBlockStatus(ctx context.Context, arg UpdateBlockStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateBlockStatus, arg.Status, arg.ChainID, arg.BlockNumber)
	return err
}
