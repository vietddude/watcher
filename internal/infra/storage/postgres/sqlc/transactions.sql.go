// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/sqlc-dev/pqtype"
)

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (
    chain_id,
    tx_hash,
    block_number,
    block_hash,
    tx_index,
    from_address,
    to_address,
    value,
    tx_type,
    token_address,
    token_amount,
    gas_used,
    gas_price,
    status,
    block_timestamp,
    raw_data,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
) ON CONFLICT (chain_id, tx_hash, block_number) DO NOTHING
`

type CreateTransactionParams struct {
	ChainID        string                `db:"chain_id" json:"chain_id"`
	TxHash         string                `db:"tx_hash" json:"tx_hash"`
	BlockNumber    int64                 `db:"block_number" json:"block_number"`
	BlockHash      string                `db:"block_hash" json:"block_hash"`
	TxIndex        int32                 `db:"tx_index" json:"tx_index"`
	FromAddress    string                `db:"from_address" json:"from_address"`
	ToAddress      sql.NullString        `db:"to_address" json:"to_address"`
	Value          sql.NullString        `db:"value" json:"value"`
	TxType         sql.NullString        `db:"tx_type" json:"tx_type"`
	TokenAddress   sql.NullString        `db:"token_address" json:"token_address"`
	TokenAmount    sql.NullString        `db:"token_amount" json:"token_amount"`
	GasUsed        sql.NullInt64         `db:"gas_used" json:"gas_used"`
	GasPrice       sql.NullString        `db:"gas_price" json:"gas_price"`
	Status         sql.NullString        `db:"status" json:"status"`
	BlockTimestamp int64                 `db:"block_timestamp" json:"block_timestamp"`
	RawData        pqtype.NullRawMessage `db:"raw_data" json:"raw_data"`
	CreatedAt      sql.NullInt64         `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createTransaction,
		arg.ChainID,
		arg.TxHash,
		arg.BlockNumber,
		arg.BlockHash,
		arg.TxIndex,
		arg.FromAddress,
		arg.ToAddress,
		arg.Value,
		arg.TxType,
		arg.TokenAddress,
		arg.TokenAmount,
		arg.GasUsed,
		arg.GasPrice,
		arg.Status,
		arg.BlockTimestamp,
		arg.RawData,
		arg.CreatedAt,
	)
	return err
}

const deleteTransactionsByBlock = `-- name: DeleteTransactionsByBlock :exec
DELETE FROM transactions
WHERE chain_id = $1 AND block_number = $2
`

type DeleteTransactionsByBlockParams struct {
	ChainID     string `db:"chain_id" json:"chain_id"`
	BlockNumber int64  `db:"block_number" json:"block_number"`
}

func (q *Queries) DeleteTransactionsByBlock(ctx context.Context, arg DeleteTransactionsByBlockParams) error {
	_, err := q.db.ExecContext(ctx, deleteTransactionsByBlock, arg.ChainID, arg.BlockNumber)
	return err
}

const deleteTransactionsOlderThan = `-- name: DeleteTransactionsOlderThan :exec
DELETE FROM transactions
WHERE chain_id = $1 AND block_timestamp < $2
`

type DeleteTransactionsOlderThanParams struct {
	ChainID        string `db:"chain_id" json:"chain_id"`
	BlockTimestamp int64  `db:"block_timestamp" json:"block_timestamp"`
}

func (q *Queries) DeleteTransactionsOlderThan(ctx context.Context, arg DeleteTransactionsOlderThanParams) error {
	_, err := q.db.ExecContext(ctx, deleteTransactionsOlderThan, arg.ChainID, arg.BlockTimestamp)
	return err
}

const getTransactionByHash = `-- name: GetTransactionByHash :one
SELECT chain_id, tx_hash, block_number, block_hash, tx_index, from_address, to_address, value, gas_used, gas_price, status, block_timestamp, raw_data, created_at, tx_type, token_address, token_amount FROM transactions
WHERE chain_id = $1 AND tx_hash = $2
LIMIT 1
`

type GetTransactionByHashParams struct {
	ChainID string `db:"chain_id" json:"chain_id"`
	TxHash  string `db:"tx_hash" json:"tx_hash"`
}

func (q *Queries) GetTransactionByHash(ctx context.Context, arg GetTransactionByHashParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByHash, arg.ChainID, arg.TxHash)
	var i Transaction
	err := row.Scan(
		&i.ChainID,
		&i.TxHash,
		&i.BlockNumber,
		&i.BlockHash,
		&i.TxIndex,
		&i.FromAddress,
		&i.ToAddress,
		&i.Value,
		&i.GasUsed,
		&i.GasPrice,
		&i.Status,
		&i.BlockTimestamp,
		&i.RawData,
		&i.CreatedAt,
		&i.TxType,
		&i.TokenAddress,
		&i.TokenAmount,
	)
	return i, err
}

const getTransactionsByBlock = `-- name: GetTransactionsByBlock :many
SELECT chain_id, tx_hash, block_number, block_hash, tx_index, from_address, to_address, value, gas_used, gas_price, status, block_timestamp, raw_data, created_at, tx_type, token_address, token_amount FROM transactions
WHERE chain_id = $1 AND block_number = $2
`

type GetTransactionsByBlockParams struct {
	ChainID     string `db:"chain_id" json:"chain_id"`
	BlockNumber int64  `db:"block_number" json:"block_number"`
}

func (q *Queries) GetTransactionsByBlock(ctx context.Context, arg GetTransactionsByBlockParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByBlock, arg.ChainID, arg.BlockNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ChainID,
			&i.TxHash,
			&i.BlockNumber,
			&i.BlockHash,
			&i.TxIndex,
			&i.FromAddress,
			&i.ToAddress,
			&i.Value,
			&i.GasUsed,
			&i.GasPrice,
			&i.Status,
			&i.BlockTimestamp,
			&i.RawData,
			&i.CreatedAt,
			&i.TxType,
			&i.TokenAddress,
			&i.TokenAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :exec
UPDATE transactions
SET status = $1
WHERE chain_id = $2 AND tx_hash = $3
`

type UpdateTransactionStatusParams struct {
	Status  sql.NullString `db:"status" json:"status"`
	ChainID string         `db:"chain_id" json:"chain_id"`
	TxHash  string         `db:"tx_hash" json:"tx_hash"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTransactionStatus, arg.Status, arg.ChainID, arg.TxHash)
	return err
}
