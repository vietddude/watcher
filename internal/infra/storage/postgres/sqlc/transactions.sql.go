// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (
    chain_id,
    tx_hash,
    block_number,
    block_hash,
    tx_index,
    from_address,
    to_address,
    value,
    tx_type,
    token_address,
    token_amount,
    gas_used,
    gas_price,
    status,
    block_timestamp,
    raw_data,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
) ON CONFLICT (chain_id, tx_hash, block_number) DO NOTHING
`

type CreateTransactionParams struct {
	ChainID        string                `db:"chain_id" json:"chain_id"`
	TxHash         string                `db:"tx_hash" json:"tx_hash"`
	BlockNumber    int64                 `db:"block_number" json:"block_number"`
	BlockHash      string                `db:"block_hash" json:"block_hash"`
	TxIndex        int32                 `db:"tx_index" json:"tx_index"`
	FromAddress    string                `db:"from_address" json:"from_address"`
	ToAddress      sql.NullString        `db:"to_address" json:"to_address"`
	Value          sql.NullString        `db:"value" json:"value"`
	TxType         sql.NullString        `db:"tx_type" json:"tx_type"`
	TokenAddress   sql.NullString        `db:"token_address" json:"token_address"`
	TokenAmount    sql.NullString        `db:"token_amount" json:"token_amount"`
	GasUsed        sql.NullInt64         `db:"gas_used" json:"gas_used"`
	GasPrice       sql.NullString        `db:"gas_price" json:"gas_price"`
	Status         sql.NullString        `db:"status" json:"status"`
	BlockTimestamp int64                 `db:"block_timestamp" json:"block_timestamp"`
	RawData        pqtype.NullRawMessage `db:"raw_data" json:"raw_data"`
	CreatedAt      sql.NullInt64         `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createTransaction,
		arg.ChainID,
		arg.TxHash,
		arg.BlockNumber,
		arg.BlockHash,
		arg.TxIndex,
		arg.FromAddress,
		arg.ToAddress,
		arg.Value,
		arg.TxType,
		arg.TokenAddress,
		arg.TokenAmount,
		arg.GasUsed,
		arg.GasPrice,
		arg.Status,
		arg.BlockTimestamp,
		arg.RawData,
		arg.CreatedAt,
	)
	return err
}

const createTransactionsBatch = `-- name: CreateTransactionsBatch :exec
INSERT INTO transactions (
    chain_id, tx_hash, block_number, block_hash, tx_index,
    from_address, to_address, value, tx_type, token_address,
    token_amount, gas_used, gas_price, status, block_timestamp, raw_data, created_at
)
SELECT
    unnest($1::varchar[]) AS chain_id,
    unnest($2::varchar[]) AS tx_hash,
    unnest($3::bigint[]) AS block_number,
    unnest($4::varchar[]) AS block_hash,
    unnest($5::int[]) AS tx_index,
    unnest($6::varchar[]) AS from_address,
    NULLIF(unnest($7::varchar[]), '') AS to_address,
    NULLIF(unnest($8::varchar[]), '') AS value,
    NULLIF(unnest($9::varchar[]), 'native') AS tx_type,
    NULLIF(unnest($10::varchar[]), '') AS token_address,
    NULLIF(unnest($11::varchar[]), '') AS token_amount,
    unnest($12::bigint[]) AS gas_used,
    unnest($13::varchar[]) AS gas_price,
    unnest($14::varchar[]) AS status,
    unnest($15::bigint[]) AS block_timestamp,
    unnest($16::text[])::jsonb AS raw_data,
    unnest($17::bigint[]) AS created_at
ON CONFLICT (chain_id, tx_hash, block_number) DO NOTHING
`

type CreateTransactionsBatchParams struct {
	Column1  []string `db:"column_1" json:"column_1"`
	Column2  []string `db:"column_2" json:"column_2"`
	Column3  []int64  `db:"column_3" json:"column_3"`
	Column4  []string `db:"column_4" json:"column_4"`
	Column5  []int32  `db:"column_5" json:"column_5"`
	Column6  []string `db:"column_6" json:"column_6"`
	Column7  []string `db:"column_7" json:"column_7"`
	Column8  []string `db:"column_8" json:"column_8"`
	Column9  []string `db:"column_9" json:"column_9"`
	Column10 []string `db:"column_10" json:"column_10"`
	Column11 []string `db:"column_11" json:"column_11"`
	Column12 []int64  `db:"column_12" json:"column_12"`
	Column13 []string `db:"column_13" json:"column_13"`
	Column14 []string `db:"column_14" json:"column_14"`
	Column15 []int64  `db:"column_15" json:"column_15"`
	Column16 []string `db:"column_16" json:"column_16"`
	Column17 []int64  `db:"column_17" json:"column_17"`
}

func (q *Queries) CreateTransactionsBatch(ctx context.Context, arg CreateTransactionsBatchParams) error {
	_, err := q.db.ExecContext(ctx, createTransactionsBatch,
		pq.Array(arg.Column1),
		pq.Array(arg.Column2),
		pq.Array(arg.Column3),
		pq.Array(arg.Column4),
		pq.Array(arg.Column5),
		pq.Array(arg.Column6),
		pq.Array(arg.Column7),
		pq.Array(arg.Column8),
		pq.Array(arg.Column9),
		pq.Array(arg.Column10),
		pq.Array(arg.Column11),
		pq.Array(arg.Column12),
		pq.Array(arg.Column13),
		pq.Array(arg.Column14),
		pq.Array(arg.Column15),
		pq.Array(arg.Column16),
		pq.Array(arg.Column17),
	)
	return err
}

const deleteTransactionsByBlock = `-- name: DeleteTransactionsByBlock :exec
DELETE FROM transactions
WHERE chain_id = $1 AND block_number = $2
`

type DeleteTransactionsByBlockParams struct {
	ChainID     string `db:"chain_id" json:"chain_id"`
	BlockNumber int64  `db:"block_number" json:"block_number"`
}

func (q *Queries) DeleteTransactionsByBlock(ctx context.Context, arg DeleteTransactionsByBlockParams) error {
	_, err := q.db.ExecContext(ctx, deleteTransactionsByBlock, arg.ChainID, arg.BlockNumber)
	return err
}

const deleteTransactionsOlderThan = `-- name: DeleteTransactionsOlderThan :exec
DELETE FROM transactions
WHERE chain_id = $1 AND block_timestamp < $2
`

type DeleteTransactionsOlderThanParams struct {
	ChainID        string `db:"chain_id" json:"chain_id"`
	BlockTimestamp int64  `db:"block_timestamp" json:"block_timestamp"`
}

func (q *Queries) DeleteTransactionsOlderThan(ctx context.Context, arg DeleteTransactionsOlderThanParams) error {
	_, err := q.db.ExecContext(ctx, deleteTransactionsOlderThan, arg.ChainID, arg.BlockTimestamp)
	return err
}

const getTransactionByHash = `-- name: GetTransactionByHash :one
SELECT chain_id, tx_hash, block_number, block_hash, tx_index, from_address, to_address, value, gas_used, gas_price, status, block_timestamp, raw_data, created_at, tx_type, token_address, token_amount FROM transactions
WHERE chain_id = $1 AND tx_hash = $2
LIMIT 1
`

type GetTransactionByHashParams struct {
	ChainID string `db:"chain_id" json:"chain_id"`
	TxHash  string `db:"tx_hash" json:"tx_hash"`
}

func (q *Queries) GetTransactionByHash(ctx context.Context, arg GetTransactionByHashParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByHash, arg.ChainID, arg.TxHash)
	var i Transaction
	err := row.Scan(
		&i.ChainID,
		&i.TxHash,
		&i.BlockNumber,
		&i.BlockHash,
		&i.TxIndex,
		&i.FromAddress,
		&i.ToAddress,
		&i.Value,
		&i.GasUsed,
		&i.GasPrice,
		&i.Status,
		&i.BlockTimestamp,
		&i.RawData,
		&i.CreatedAt,
		&i.TxType,
		&i.TokenAddress,
		&i.TokenAmount,
	)
	return i, err
}

const getTransactionsByBlock = `-- name: GetTransactionsByBlock :many
SELECT chain_id, tx_hash, block_number, block_hash, tx_index, from_address, to_address, value, gas_used, gas_price, status, block_timestamp, raw_data, created_at, tx_type, token_address, token_amount FROM transactions
WHERE chain_id = $1 AND block_number = $2
`

type GetTransactionsByBlockParams struct {
	ChainID     string `db:"chain_id" json:"chain_id"`
	BlockNumber int64  `db:"block_number" json:"block_number"`
}

func (q *Queries) GetTransactionsByBlock(ctx context.Context, arg GetTransactionsByBlockParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByBlock, arg.ChainID, arg.BlockNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ChainID,
			&i.TxHash,
			&i.BlockNumber,
			&i.BlockHash,
			&i.TxIndex,
			&i.FromAddress,
			&i.ToAddress,
			&i.Value,
			&i.GasUsed,
			&i.GasPrice,
			&i.Status,
			&i.BlockTimestamp,
			&i.RawData,
			&i.CreatedAt,
			&i.TxType,
			&i.TokenAddress,
			&i.TokenAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :exec
UPDATE transactions
SET status = $1
WHERE chain_id = $2 AND tx_hash = $3
`

type UpdateTransactionStatusParams struct {
	Status  sql.NullString `db:"status" json:"status"`
	ChainID string         `db:"chain_id" json:"chain_id"`
	TxHash  string         `db:"tx_hash" json:"tx_hash"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTransactionStatus, arg.Status, arg.ChainID, arg.TxHash)
	return err
}
